// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'category.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$ProductCategoryTearOff {
  const _$ProductCategoryTearOff();

// ignore: unused_element
  ElectronicsProductCategory electronics() {
    return const ElectronicsProductCategory();
  }

// ignore: unused_element
  JeweleryProductCategory jewelery() {
    return const JeweleryProductCategory();
  }

// ignore: unused_element
  MenClothingProductCategory menClothing() {
    return const MenClothingProductCategory();
  }

// ignore: unused_element
  OtherProductCategory other() {
    return const OtherProductCategory();
  }

// ignore: unused_element
  WomenClothingProductCategory womenClothing() {
    return const WomenClothingProductCategory();
  }
}

/// @nodoc
// ignore: unused_element
const $ProductCategory = _$ProductCategoryTearOff();

/// @nodoc
mixin _$ProductCategory {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult electronics(),
    @required TResult jewelery(),
    @required TResult menClothing(),
    @required TResult other(),
    @required TResult womenClothing(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult electronics(),
    TResult jewelery(),
    TResult menClothing(),
    TResult other(),
    TResult womenClothing(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult electronics(ElectronicsProductCategory value),
    @required TResult jewelery(JeweleryProductCategory value),
    @required TResult menClothing(MenClothingProductCategory value),
    @required TResult other(OtherProductCategory value),
    @required TResult womenClothing(WomenClothingProductCategory value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult electronics(ElectronicsProductCategory value),
    TResult jewelery(JeweleryProductCategory value),
    TResult menClothing(MenClothingProductCategory value),
    TResult other(OtherProductCategory value),
    TResult womenClothing(WomenClothingProductCategory value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $ProductCategoryCopyWith<$Res> {
  factory $ProductCategoryCopyWith(
          ProductCategory value, $Res Function(ProductCategory) then) =
      _$ProductCategoryCopyWithImpl<$Res>;
}

/// @nodoc
class _$ProductCategoryCopyWithImpl<$Res>
    implements $ProductCategoryCopyWith<$Res> {
  _$ProductCategoryCopyWithImpl(this._value, this._then);

  final ProductCategory _value;
  // ignore: unused_field
  final $Res Function(ProductCategory) _then;
}

/// @nodoc
abstract class $ElectronicsProductCategoryCopyWith<$Res> {
  factory $ElectronicsProductCategoryCopyWith(ElectronicsProductCategory value,
          $Res Function(ElectronicsProductCategory) then) =
      _$ElectronicsProductCategoryCopyWithImpl<$Res>;
}

/// @nodoc
class _$ElectronicsProductCategoryCopyWithImpl<$Res>
    extends _$ProductCategoryCopyWithImpl<$Res>
    implements $ElectronicsProductCategoryCopyWith<$Res> {
  _$ElectronicsProductCategoryCopyWithImpl(ElectronicsProductCategory _value,
      $Res Function(ElectronicsProductCategory) _then)
      : super(_value, (v) => _then(v as ElectronicsProductCategory));

  @override
  ElectronicsProductCategory get _value =>
      super._value as ElectronicsProductCategory;
}

/// @nodoc
class _$ElectronicsProductCategory implements ElectronicsProductCategory {
  const _$ElectronicsProductCategory();

  @override
  String toString() {
    return 'ProductCategory.electronics()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ElectronicsProductCategory);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult electronics(),
    @required TResult jewelery(),
    @required TResult menClothing(),
    @required TResult other(),
    @required TResult womenClothing(),
  }) {
    assert(electronics != null);
    assert(jewelery != null);
    assert(menClothing != null);
    assert(other != null);
    assert(womenClothing != null);
    return electronics();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult electronics(),
    TResult jewelery(),
    TResult menClothing(),
    TResult other(),
    TResult womenClothing(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (electronics != null) {
      return electronics();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult electronics(ElectronicsProductCategory value),
    @required TResult jewelery(JeweleryProductCategory value),
    @required TResult menClothing(MenClothingProductCategory value),
    @required TResult other(OtherProductCategory value),
    @required TResult womenClothing(WomenClothingProductCategory value),
  }) {
    assert(electronics != null);
    assert(jewelery != null);
    assert(menClothing != null);
    assert(other != null);
    assert(womenClothing != null);
    return electronics(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult electronics(ElectronicsProductCategory value),
    TResult jewelery(JeweleryProductCategory value),
    TResult menClothing(MenClothingProductCategory value),
    TResult other(OtherProductCategory value),
    TResult womenClothing(WomenClothingProductCategory value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (electronics != null) {
      return electronics(this);
    }
    return orElse();
  }
}

abstract class ElectronicsProductCategory implements ProductCategory {
  const factory ElectronicsProductCategory() = _$ElectronicsProductCategory;
}

/// @nodoc
abstract class $JeweleryProductCategoryCopyWith<$Res> {
  factory $JeweleryProductCategoryCopyWith(JeweleryProductCategory value,
          $Res Function(JeweleryProductCategory) then) =
      _$JeweleryProductCategoryCopyWithImpl<$Res>;
}

/// @nodoc
class _$JeweleryProductCategoryCopyWithImpl<$Res>
    extends _$ProductCategoryCopyWithImpl<$Res>
    implements $JeweleryProductCategoryCopyWith<$Res> {
  _$JeweleryProductCategoryCopyWithImpl(JeweleryProductCategory _value,
      $Res Function(JeweleryProductCategory) _then)
      : super(_value, (v) => _then(v as JeweleryProductCategory));

  @override
  JeweleryProductCategory get _value => super._value as JeweleryProductCategory;
}

/// @nodoc
class _$JeweleryProductCategory implements JeweleryProductCategory {
  const _$JeweleryProductCategory();

  @override
  String toString() {
    return 'ProductCategory.jewelery()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is JeweleryProductCategory);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult electronics(),
    @required TResult jewelery(),
    @required TResult menClothing(),
    @required TResult other(),
    @required TResult womenClothing(),
  }) {
    assert(electronics != null);
    assert(jewelery != null);
    assert(menClothing != null);
    assert(other != null);
    assert(womenClothing != null);
    return jewelery();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult electronics(),
    TResult jewelery(),
    TResult menClothing(),
    TResult other(),
    TResult womenClothing(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (jewelery != null) {
      return jewelery();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult electronics(ElectronicsProductCategory value),
    @required TResult jewelery(JeweleryProductCategory value),
    @required TResult menClothing(MenClothingProductCategory value),
    @required TResult other(OtherProductCategory value),
    @required TResult womenClothing(WomenClothingProductCategory value),
  }) {
    assert(electronics != null);
    assert(jewelery != null);
    assert(menClothing != null);
    assert(other != null);
    assert(womenClothing != null);
    return jewelery(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult electronics(ElectronicsProductCategory value),
    TResult jewelery(JeweleryProductCategory value),
    TResult menClothing(MenClothingProductCategory value),
    TResult other(OtherProductCategory value),
    TResult womenClothing(WomenClothingProductCategory value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (jewelery != null) {
      return jewelery(this);
    }
    return orElse();
  }
}

abstract class JeweleryProductCategory implements ProductCategory {
  const factory JeweleryProductCategory() = _$JeweleryProductCategory;
}

/// @nodoc
abstract class $MenClothingProductCategoryCopyWith<$Res> {
  factory $MenClothingProductCategoryCopyWith(MenClothingProductCategory value,
          $Res Function(MenClothingProductCategory) then) =
      _$MenClothingProductCategoryCopyWithImpl<$Res>;
}

/// @nodoc
class _$MenClothingProductCategoryCopyWithImpl<$Res>
    extends _$ProductCategoryCopyWithImpl<$Res>
    implements $MenClothingProductCategoryCopyWith<$Res> {
  _$MenClothingProductCategoryCopyWithImpl(MenClothingProductCategory _value,
      $Res Function(MenClothingProductCategory) _then)
      : super(_value, (v) => _then(v as MenClothingProductCategory));

  @override
  MenClothingProductCategory get _value =>
      super._value as MenClothingProductCategory;
}

/// @nodoc
class _$MenClothingProductCategory implements MenClothingProductCategory {
  const _$MenClothingProductCategory();

  @override
  String toString() {
    return 'ProductCategory.menClothing()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is MenClothingProductCategory);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult electronics(),
    @required TResult jewelery(),
    @required TResult menClothing(),
    @required TResult other(),
    @required TResult womenClothing(),
  }) {
    assert(electronics != null);
    assert(jewelery != null);
    assert(menClothing != null);
    assert(other != null);
    assert(womenClothing != null);
    return menClothing();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult electronics(),
    TResult jewelery(),
    TResult menClothing(),
    TResult other(),
    TResult womenClothing(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (menClothing != null) {
      return menClothing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult electronics(ElectronicsProductCategory value),
    @required TResult jewelery(JeweleryProductCategory value),
    @required TResult menClothing(MenClothingProductCategory value),
    @required TResult other(OtherProductCategory value),
    @required TResult womenClothing(WomenClothingProductCategory value),
  }) {
    assert(electronics != null);
    assert(jewelery != null);
    assert(menClothing != null);
    assert(other != null);
    assert(womenClothing != null);
    return menClothing(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult electronics(ElectronicsProductCategory value),
    TResult jewelery(JeweleryProductCategory value),
    TResult menClothing(MenClothingProductCategory value),
    TResult other(OtherProductCategory value),
    TResult womenClothing(WomenClothingProductCategory value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (menClothing != null) {
      return menClothing(this);
    }
    return orElse();
  }
}

abstract class MenClothingProductCategory implements ProductCategory {
  const factory MenClothingProductCategory() = _$MenClothingProductCategory;
}

/// @nodoc
abstract class $OtherProductCategoryCopyWith<$Res> {
  factory $OtherProductCategoryCopyWith(OtherProductCategory value,
          $Res Function(OtherProductCategory) then) =
      _$OtherProductCategoryCopyWithImpl<$Res>;
}

/// @nodoc
class _$OtherProductCategoryCopyWithImpl<$Res>
    extends _$ProductCategoryCopyWithImpl<$Res>
    implements $OtherProductCategoryCopyWith<$Res> {
  _$OtherProductCategoryCopyWithImpl(
      OtherProductCategory _value, $Res Function(OtherProductCategory) _then)
      : super(_value, (v) => _then(v as OtherProductCategory));

  @override
  OtherProductCategory get _value => super._value as OtherProductCategory;
}

/// @nodoc
class _$OtherProductCategory implements OtherProductCategory {
  const _$OtherProductCategory();

  @override
  String toString() {
    return 'ProductCategory.other()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is OtherProductCategory);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult electronics(),
    @required TResult jewelery(),
    @required TResult menClothing(),
    @required TResult other(),
    @required TResult womenClothing(),
  }) {
    assert(electronics != null);
    assert(jewelery != null);
    assert(menClothing != null);
    assert(other != null);
    assert(womenClothing != null);
    return other();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult electronics(),
    TResult jewelery(),
    TResult menClothing(),
    TResult other(),
    TResult womenClothing(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (other != null) {
      return other();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult electronics(ElectronicsProductCategory value),
    @required TResult jewelery(JeweleryProductCategory value),
    @required TResult menClothing(MenClothingProductCategory value),
    @required TResult other(OtherProductCategory value),
    @required TResult womenClothing(WomenClothingProductCategory value),
  }) {
    assert(electronics != null);
    assert(jewelery != null);
    assert(menClothing != null);
    assert(other != null);
    assert(womenClothing != null);
    return other(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult electronics(ElectronicsProductCategory value),
    TResult jewelery(JeweleryProductCategory value),
    TResult menClothing(MenClothingProductCategory value),
    TResult other(OtherProductCategory value),
    TResult womenClothing(WomenClothingProductCategory value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (other != null) {
      return other(this);
    }
    return orElse();
  }
}

abstract class OtherProductCategory implements ProductCategory {
  const factory OtherProductCategory() = _$OtherProductCategory;
}

/// @nodoc
abstract class $WomenClothingProductCategoryCopyWith<$Res> {
  factory $WomenClothingProductCategoryCopyWith(
          WomenClothingProductCategory value,
          $Res Function(WomenClothingProductCategory) then) =
      _$WomenClothingProductCategoryCopyWithImpl<$Res>;
}

/// @nodoc
class _$WomenClothingProductCategoryCopyWithImpl<$Res>
    extends _$ProductCategoryCopyWithImpl<$Res>
    implements $WomenClothingProductCategoryCopyWith<$Res> {
  _$WomenClothingProductCategoryCopyWithImpl(
      WomenClothingProductCategory _value,
      $Res Function(WomenClothingProductCategory) _then)
      : super(_value, (v) => _then(v as WomenClothingProductCategory));

  @override
  WomenClothingProductCategory get _value =>
      super._value as WomenClothingProductCategory;
}

/// @nodoc
class _$WomenClothingProductCategory implements WomenClothingProductCategory {
  const _$WomenClothingProductCategory();

  @override
  String toString() {
    return 'ProductCategory.womenClothing()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is WomenClothingProductCategory);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult electronics(),
    @required TResult jewelery(),
    @required TResult menClothing(),
    @required TResult other(),
    @required TResult womenClothing(),
  }) {
    assert(electronics != null);
    assert(jewelery != null);
    assert(menClothing != null);
    assert(other != null);
    assert(womenClothing != null);
    return womenClothing();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult electronics(),
    TResult jewelery(),
    TResult menClothing(),
    TResult other(),
    TResult womenClothing(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (womenClothing != null) {
      return womenClothing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult electronics(ElectronicsProductCategory value),
    @required TResult jewelery(JeweleryProductCategory value),
    @required TResult menClothing(MenClothingProductCategory value),
    @required TResult other(OtherProductCategory value),
    @required TResult womenClothing(WomenClothingProductCategory value),
  }) {
    assert(electronics != null);
    assert(jewelery != null);
    assert(menClothing != null);
    assert(other != null);
    assert(womenClothing != null);
    return womenClothing(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult electronics(ElectronicsProductCategory value),
    TResult jewelery(JeweleryProductCategory value),
    TResult menClothing(MenClothingProductCategory value),
    TResult other(OtherProductCategory value),
    TResult womenClothing(WomenClothingProductCategory value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (womenClothing != null) {
      return womenClothing(this);
    }
    return orElse();
  }
}

abstract class WomenClothingProductCategory implements ProductCategory {
  const factory WomenClothingProductCategory() = _$WomenClothingProductCategory;
}
